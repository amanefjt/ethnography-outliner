// ============================================================================
// CONSTANTS - マジックナンバーの集約
// ============================================================================
const CONSTANTS = {
    NOTE_WIDTH: 300,
    NOTE_HEIGHT: 150,
    GROUP_PADDING: 24,
    GROUP_MARGIN_TOP: 64,
    GROUP_MARGIN_HORIZONTAL: 48,
    GROUP_MARGIN_VERTICAL: 88,
    ZOOM_MIN: 0.1,
    ZOOM_MAX: 3,
    ZOOM_STEP_WHEEL: 0.05,
    ZOOM_STEP_BUTTON: 0.2,
    DELETE_CONFIRM_TIMEOUT: 3000,
    COLORS: ['slate', 'blue', 'green', 'yellow', 'rose', 'orange', 'purple'],
    DEFAULT_GROUP_WIDTH: 400,
    DEFAULT_GROUP_HEIGHT: 300,
    DEFAULT_RELATION_LABEL: '関係',
    GROUP_HEADER_HEIGHT: 40,
    DASH_PATTERNS: ['none', '5,5', '10,5', '2,4', '15,5,5,5']
};

// ============================================================================
// STATE MANAGEMENT - 状態管理
// ============================================================================
let state = {
    notes: [],
    groups: [],
    relations: [],
    selectedIds: [],
    outlineOrder: {},
    activeView: 'canvas',
    dragItem: null,
    dragType: null,
    dragOffset: { x: 0, y: 0 },
    connectingSource: null,
    zoom: 1,
    offset: { x: 0, y: 0 },
    isPanning: false,
    pendingDelete: null,
    creationPos: { x: 100, y: 100 },
    resizeEdge: null,
    originalBounds: null,
    history: { past: [], future: [] }
};

const DOM = {
    canvas: null,
    canvasContainer: null,
    outlineList: null,
    canvasView: null,
    outlinerView: null,
    viewToggle: null,
    addNoteBtn: null,
    addGroupBtn: null,
    noteModal: null,
    noteInput: null,
    saveNoteBtn: null,
    cancelNoteBtn: null,
    rearrangeBtn: null,
    zoomInBtn: null,
    zoomOutBtn: null,
    importBtn: null,
    importModal: null,
    importInput: null,
    saveImportBtn: null,
    cancelImportBtn: null,
    viewModal: null,
    viewTitle: null,
    viewBody: null,
    closeViewBtn: null,
    undoBtn: null,
    redoBtn: null
};

let currentMouseCanvasPos = { x: 200, y: 200 };

// ============================================================================
// INITIALIZATION
// ============================================================================
function init() {
    try {
        cacheDOMElements();
        loadStateFromStorage();
        initializeDefaultData();
        renderCanvas();
        setupEventListeners();
    } catch (error) {
        console.error('初期化エラー:', error);
    }
}

function cacheDOMElements() {
    DOM.canvas = document.getElementById('canvas');
    DOM.canvasContainer = document.getElementById('canvas-container');
    DOM.outlineList = document.getElementById('outline-list');
    DOM.canvasView = document.getElementById('canvas-view');
    DOM.outlinerView = document.getElementById('outliner-view');
    DOM.viewToggle = document.getElementById('view-toggle');
    DOM.addNoteBtn = document.getElementById('add-note');
    DOM.addGroupBtn = document.getElementById('add-group');
    DOM.noteModal = document.getElementById('note-modal');
    DOM.noteInput = document.getElementById('note-input');
    DOM.saveNoteBtn = document.getElementById('save-note');
    DOM.cancelNoteBtn = document.getElementById('cancel-note');
    DOM.rearrangeBtn = document.getElementById('rearrange');
    DOM.zoomInBtn = document.getElementById('zoom-in');
    DOM.zoomOutBtn = document.getElementById('zoom-out');
    DOM.importBtn = document.getElementById('import-text');
    DOM.importModal = document.getElementById('import-modal');
    DOM.importInput = document.getElementById('import-input');
    DOM.saveImportBtn = document.getElementById('save-import');
    DOM.cancelImportBtn = document.getElementById('cancel-import');
    DOM.noteTitleInput = document.getElementById('note-title-input'); // Added Init
    DOM.viewModal = document.getElementById('view-modal');
    DOM.viewTitle = document.getElementById('view-title');
    DOM.viewBody = document.getElementById('view-body');
    DOM.closeViewBtn = document.getElementById('close-view');
    DOM.undoBtn = document.getElementById('undo');
    DOM.redoBtn = document.getElementById('redo');
}

function loadStateFromStorage() {
    try {
        state.notes = JSON.parse(localStorage.getItem('ethnography-notes')) || [];
        state.groups = JSON.parse(localStorage.getItem('ethnography-groups')) || [];
        state.relations = JSON.parse(localStorage.getItem('ethnography-relations')) || [];
        state.outlineOrder = JSON.parse(localStorage.getItem('ethnography-order')) || {};
    } catch (e) {
        console.error('Storage load error', e);
    }
}

function saveData() {
    localStorage.setItem('ethnography-notes', JSON.stringify(state.notes));
    localStorage.setItem('ethnography-groups', JSON.stringify(state.groups));
    localStorage.setItem('ethnography-relations', JSON.stringify(state.relations));
    localStorage.setItem('ethnography-order', JSON.stringify(state.outlineOrder));
}

function initializeDefaultData() {
    if (state.notes.length === 0 && state.groups.length === 0) {
        state.notes = [{ id: 1, title: "ノート 1", content: "これは最初のノートです。ドラッグして動かしたり、ダブルクリックで編集できます。", x: 400, y: 150, color: 'blue', collapsed: false }];
    }
}

// ============================================================================
// RENDERING
// ============================================================================
function renderCanvas() {
    if (!DOM.canvas) return;
    DOM.canvas.innerHTML = '';
    DOM.canvas.style.transform = `scale(${state.zoom}) translate(${state.offset.x}px, ${state.offset.y}px)`;
    renderGroups();
    renderNotes();
    const svgLayer = createSVGLayer();
    const labelsLayer = document.createElement('div');
    labelsLayer.id = 'labels-layer';
    labelsLayer.style.position = 'absolute';
    labelsLayer.style.inset = '0';
    labelsLayer.style.pointerEvents = 'none';
    labelsLayer.style.zIndex = '950';
    DOM.canvas.appendChild(labelsLayer);
    renderRelations(svgLayer, labelsLayer);
    renderQuickActions();
    renderOutline();
    updateUndoRedoButtons();
    lucide.createIcons();
}

function createSVGLayer() {
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.id = 'connector-layer';
    svg.setAttribute('class', 'connector-layer');
    DOM.canvas.appendChild(svg);
    return svg;
}

// --- Group Rendering ---
function renderGroups() {
    // 括りが消える問題を修正: 親（一番外側）を先に、入れ子になっているものを後に描画
    const sortedGroups = [...state.groups].sort((a, b) => {
        return getGroupDepth(a.id) - getGroupDepth(b.id);
    });

    sortedGroups.forEach(group => {
        if (isParentCollapsed(group.groupId)) return;
        const el = createGroupElement(group);
        // 子であるほど大きな z-index を持たせることで、親を選択しても隠れないようにする
        const depth = getGroupDepth(group.id);
        el.style.zIndex = depth * 10;
        if (state.selectedIds.includes(group.id)) {
            el.style.zIndex = depth * 10 + 5;
        }
        attachGroupEventListeners(el, group);
        DOM.canvas.appendChild(el);
    });
}

function getGroupDepth(id, visited = new Set()) {
    if (!id || visited.has(id)) return 0;
    visited.add(id);
    const g = state.groups.find(x => x.id === id);
    if (!g || !g.groupId) return 0;
    return 1 + getGroupDepth(g.groupId, visited);
}

function createGroupElement(group) {
    const el = document.createElement('div');
    const isPending = state.pendingDelete && state.pendingDelete.id === group.id;
    el.className = `group-card color-${group.color || 'blue'} ${state.selectedIds.includes(group.id) ? 'selected' : ''} ${group.isGhost ? 'ghost' : ''} ${group.collapsed ? 'collapsed' : ''}`;
    el.style.left = `${group.x}px`;
    el.style.top = `${group.y}px`;
    el.style.width = `${group.width || CONSTANTS.DEFAULT_GROUP_WIDTH}px`;
    el.style.height = `${group.height || CONSTANTS.DEFAULT_GROUP_HEIGHT}px`;
    el.dataset.id = group.id;

    const chevron = group.collapsed ? 'chevron-right' : 'chevron-down';
    el.innerHTML = `
        <div class="group-header">
            <button class="btn-collapse"><i data-lucide="${chevron}"></i></button>
            <input type="text" value="${escapeHtml(group.title)}" />
        </div>
        <div class="item-actions">
            <button class="action-btn btn-duplicate" title="複製"><i data-lucide="copy"></i></button>
            <button class="action-btn btn-connect" title="関係付け"><i data-lucide="link"></i></button>
            <button class="action-btn btn-ghost" title="半透明"><i data-lucide="eye"></i></button>
            <button class="action-btn btn-color" title="色変更"><i data-lucide="palette"></i></button>
            <button class="action-btn btn-delete ${isPending ? 'pending' : ''}" title="削除"><i data-lucide="${isPending ? 'check' : 'trash-2'}"></i></button>
        </div>
    `;
    return el;
}

// --- Note Rendering ---
function renderNotes() {
    state.notes.forEach(note => {
        if (isParentCollapsed(note.groupId)) return;
        const el = createNoteElement(note);
        // ノートは同じ階層のグループより常に手前に表示
        const depth = note.groupId ? getGroupDepth(note.groupId) + 1 : 0;
        el.style.zIndex = depth * 10 + 100; // ベースとしてグループより高い値を設定
        if (state.selectedIds.includes(note.id)) {
            el.style.zIndex = depth * 10 + 500;
        }
        attachNoteEventListeners(el, note);
        DOM.canvas.appendChild(el);
    });
}

function createNoteElement(note) {
    const el = document.createElement('div');
    const isPending = state.pendingDelete && state.pendingDelete.id === note.id;
    el.className = `note-card color-${note.color || 'slate'} ${state.selectedIds.includes(note.id) ? 'selected' : ''} ${note.isGhost ? 'ghost' : ''} ${note.collapsed ? 'collapsed' : ''}`;
    el.style.left = `${note.x}px`;
    el.style.top = `${note.y}px`;
    el.style.width = `${note.width || CONSTANTS.NOTE_WIDTH}px`;
    el.style.height = `${note.height || CONSTANTS.NOTE_HEIGHT}px`;
    el.dataset.id = note.id;

    const chevron = note.collapsed ? 'chevron-right' : 'chevron-down';
    el.innerHTML = `
        <div class="header-row">
            <button class="btn-collapse"><i data-lucide="${chevron}"></i></button>
            <input type="text" class="title-input" value="${escapeHtml(note.title || '')}" placeholder="タイトルなし" />
        </div>
        <div class="content">${escapeHtml(note.content)}</div>
        <div class="meta"><span>ID: ${note.id}</span></div>
        <div class="item-actions">
            <button class="action-btn btn-maximize" title="全文表示"><i data-lucide="maximize-2"></i></button>
            <button class="action-btn btn-duplicate" title="複製"><i data-lucide="copy"></i></button>
            <button class="action-btn btn-connect" title="関係付け"><i data-lucide="link"></i></button>
            <button class="action-btn btn-ghost" title="半透明"><i data-lucide="eye"></i></button>
            <button class="action-btn btn-color" title="色変更"><i data-lucide="palette"></i></button>
            <button class="action-btn btn-delete ${isPending ? 'pending' : ''}" title="削除"><i data-lucide="${isPending ? 'check' : 'trash-2'}"></i></button>
        </div>
    `;
    return el;
}

// ============================================================================
// DRAG & RESIZE
// ============================================================================
function setupEventListeners() {
    DOM.canvasContainer.onmousemove = e => {
        const rect = DOM.canvasContainer.getBoundingClientRect();
        currentMouseCanvasPos.x = (e.clientX - rect.left) / state.zoom - state.offset.x;
        currentMouseCanvasPos.y = (e.clientY - rect.top) / state.zoom - state.offset.y;
        if (state.connectingSource) renderCanvas();
    };

    DOM.canvasContainer.onwheel = e => {
        if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const rect = DOM.canvasContainer.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            // ズーム前のマウス位置のキャンバス座標
            const cx = mx / state.zoom - state.offset.x;
            const cy = my / state.zoom - state.offset.y;

            const factor = e.deltaY > 0 ? (1 - CONSTANTS.ZOOM_STEP_WHEEL) : (1 + CONSTANTS.ZOOM_STEP_WHEEL);
            const newZoom = Math.min(Math.max(CONSTANTS.ZOOM_MIN, state.zoom * factor), CONSTANTS.ZOOM_MAX);

            // ズーム後のオフセット調整（マウス位置を固定）
            state.offset.x = mx / newZoom - cx;
            state.offset.y = my / newZoom - cy;
            state.zoom = newZoom;
        } else {
            state.offset.x -= e.deltaX / state.zoom;
            state.offset.y -= e.deltaY / state.zoom;
        }
        renderCanvas();
    };

    DOM.canvasContainer.onmousedown = e => {
        if (e.target === DOM.canvasContainer || e.target === DOM.canvas) {
            state.selectedIds = [];
            state.isPanning = (e.button === 1 || e.altKey);
            renderCanvas();
        }
    };

    window.onmousemove = drag;
    window.onmouseup = endDrag;

    DOM.addNoteBtn.onclick = openNoteModal;
    DOM.saveNoteBtn.onclick = saveNote;
    DOM.cancelNoteBtn.onclick = closeNoteModal;
    DOM.addGroupBtn.onclick = addGroup;
    DOM.zoomInBtn.onclick = () => { state.zoom = Math.min(CONSTANTS.ZOOM_MAX, state.zoom * 1.2); renderCanvas(); };
    DOM.zoomOutBtn.onclick = () => { state.zoom = Math.max(CONSTANTS.ZOOM_MIN, state.zoom / 1.2); renderCanvas(); };
    DOM.importBtn.onclick = openImportModal;
    DOM.saveImportBtn.onclick = handleImport;
    DOM.cancelImportBtn.onclick = closeImportModal;
    DOM.closeViewBtn.onclick = closeViewModal;
    DOM.viewToggle.onclick = toggleView;
    DOM.undoBtn.onclick = undo;
    DOM.redoBtn.onclick = redo;

    window.addEventListener('keydown', e => {
        const isCmd = e.metaKey || e.ctrlKey;
        if (isCmd && e.key.toLowerCase() === 'z') {
            e.preventDefault();
            if (e.shiftKey) redo(); else undo();
        } else if (isCmd && e.key.toLowerCase() === 'y') {
            e.preventDefault();
            redo();
        } else if (e.key === 'Escape') {
            state.selectedIds = [];
            closeNoteModal();
            closeImportModal();
            closeViewModal();
            renderCanvas();
        }
    });
}

function startDrag(e, type) {
    if (e.target.tagName === 'INPUT' || e.target.closest('.action-btn') || e.target.closest('.btn-collapse')) return;
    const id = e.currentTarget.dataset.id;
    const pid = type === 'note' ? parseInt(id) : id;

    if (e.metaKey || e.ctrlKey) {
        if (state.selectedIds.includes(pid)) state.selectedIds = state.selectedIds.filter(s => s !== pid);
        else state.selectedIds.push(pid);
        renderCanvas();
        return;
    }

    if (!state.selectedIds.includes(pid)) state.selectedIds = [pid];
    state.dragItem = pid;
    state.dragType = type;
    const item = type === 'note' ? state.notes.find(n => n.id === pid) : state.groups.find(g => g.id === pid);
    if (item) {
        state.dragOffset.x = currentMouseCanvasPos.x - item.x;
        state.dragOffset.y = currentMouseCanvasPos.y - item.y;
    }

    // 関係付けモード中ならターゲット確定
    if (state.connectingSource) {
        const source = state.connectingSource;
        if (source !== pid) {
            pushHistory();
            state.relations.push({
                source,
                target: pid,
                id: Date.now(),
                dash: CONSTANTS.DASH_PATTERNS[Math.floor(Math.random() * CONSTANTS.DASH_PATTERNS.length)]
            });
            state.connectingSource = null;
            renderCanvas();
            saveData();
        }
        return;
    }
    renderCanvas();
}

function drag(e) {
    if (state.dragType === 'resize') { handleResize(e); renderCanvas(); return; }
    if (state.isPanning) {
        state.offset.x += e.movementX / state.zoom;
        state.offset.y += e.movementY / state.zoom;
        renderCanvas(); return;
    }
    if (!state.dragItem) return;

    const item = state.dragType === 'note' ? state.notes.find(n => n.id === state.dragItem) : state.groups.find(g => g.id === state.dragItem);
    if (!item) return;

    const rect = DOM.canvasContainer.getBoundingClientRect();
    const nx = (e.clientX - rect.left) / state.zoom - state.offset.x - state.dragOffset.x;
    const ny = (e.clientY - rect.top) / state.zoom - state.offset.y - state.dragOffset.y;
    const dx = nx - item.x;
    const dy = ny - item.y;

    item.x = nx; item.y = ny;

    if (state.dragType === 'note') {
        const g = state.groups.find(gr => nx >= gr.x && nx <= gr.x + gr.width && ny >= gr.y && ny <= gr.y + gr.height);
        item.groupId = g ? g.id : null;
    } else {
        moveGroupAndChildren(item.id, dx, dy);
        const target = state.groups.find(gr => gr.id !== item.id && gr.groupId !== item.id && item.x >= gr.x && item.x + item.width <= gr.x + gr.width && item.y >= gr.y && item.y + item.height <= gr.y + gr.height);
        item.groupId = target ? target.id : (isItemOutOfBounds(item) ? null : item.groupId);
    }
    renderCanvas();
}

function isItemOutOfBounds(item) {
    if (!item.groupId) return false;
    const p = state.groups.find(g => g.id === item.groupId);
    if (!p) return false;
    return item.x < p.x || item.y < p.y || item.x + (item.width || 0) > p.x + p.width || item.y + (item.height || 0) > p.y + p.height;
}

function moveGroupAndChildren(groupId, dx, dy) {
    state.notes.filter(n => n.groupId === groupId).forEach(n => { n.x += dx; n.y += dy; });
    state.groups.filter(g => g.groupId === groupId).forEach(g => { g.x += dx; g.y += dy; moveGroupAndChildren(g.id, dx, dy); });
}

function getItemBounds(item) {
    const isG = typeof item.id === 'string' && item.id.startsWith('g');
    return {
        x: item.x,
        y: item.y,
        w: item.width || (isG ? CONSTANTS.DEFAULT_GROUP_WIDTH : CONSTANTS.NOTE_WIDTH),
        h: item.height || (isG ? CONSTANTS.DEFAULT_GROUP_HEIGHT : CONSTANTS.NOTE_HEIGHT)
    };
}

function endDrag() {
    if (state.dragItem) {
        cleanupEmptyGroups();
    }
    state.dragItem = state.dragType = state.resizeEdge = state.originalBounds = null;
    state.isPanning = false;
    saveData();
}

function handleResize(e) {
    if (!state.dragItem || !state.resizeEdge || !state.originalBounds) return;
    const rect = DOM.canvasContainer.getBoundingClientRect();
    const mx = (e.clientX - rect.left) / state.zoom - state.offset.x;
    const my = (e.clientY - rect.top) / state.zoom - state.offset.y;
    const item = state.dragItem;
    if (state.resizeEdge.includes('s')) item.height = Math.max(100, my - item.y);
    if (state.resizeEdge.includes('e')) item.width = Math.max(150, mx - item.x);
}

// ============================================================================
// IMPORT & MODALS
// ============================================================================
function handleImport() {
    console.log("Starting import...");
    const text = DOM.importInput.value.trim();
    if (!text) return;

    let items = [];
    const lines = text.split('\n');
    const isMd = lines.some(l => l.trim().startsWith('- '));

    if (isMd) {
        let current = null;
        lines.forEach(line => {
            const top = line.match(/^-\s+(.*)/);
            const sub = line.match(/^\s+-\s+(.*)/);
            if (top) {
                if (current) items.push(current);
                current = { first: top[1].trim(), second: [] };
            }
            else if (sub) {
                if (current) current.second.push(sub[1].trim());
                else items.push({ title: "", content: sub[1].trim() });
            }
            else if (current) {
                if (current.second.length) current.second[current.second.length - 1] += ' ' + line.trim();
                else current.first += ' ' + line.trim();
            }
        });
        if (current) items.push(current);
        items = items.map(it => ({
            title: it.second.length ? it.first : "",
            content: it.second.length ? it.second.join('\n\n') : it.first
        }));
    } else {
        items = text.split(/\n\s*\n/).map(p => ({ title: "", content: p.trim() })).filter(p => p.content);
    }

    items.forEach((it, i) => {
        const p = findEmptyPosition(currentMouseCanvasPos.x + i * 20, currentMouseCanvasPos.y + i * 20, 300, 150);
        state.notes.push({ id: Date.now() + i, title: it.title, content: it.content, x: p.x, y: p.y, color: 'slate', collapsed: false });
    });
    renderCanvas(); saveData(); closeImportModal();
}

// ============================================================================
// BUSINESS LOGIC
// ============================================================================
function updateGroupBounds(gid) {
    const g = state.groups.find(x => x.id === gid);
    if (!g) return;
    const notes = state.notes.filter(n => n.groupId === gid);
    const subs = state.groups.filter(gr => gr.groupId === gid);
    if (!notes.length && !subs.length) return;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    notes.forEach(n => { minX = Math.min(minX, n.x); minY = Math.min(minY, n.y); maxX = Math.max(maxX, n.x + 300); maxY = Math.max(maxY, n.y + (n.collapsed ? 40 : 150)); });
    subs.forEach(s => { minX = Math.min(minX, s.x); minY = Math.min(minY, s.y); maxX = Math.max(maxX, s.x + (s.width || 400)); maxY = Math.max(maxY, s.y + (s.collapsed ? 40 : (s.height || 300))); });
    g.x = minX - 24; g.y = minY - 64; g.width = maxX - minX + 48; g.height = maxY - minY + 88;
    if (g.groupId) updateGroupBounds(g.groupId);
}

function cleanupEmptyGroups() {
    let changed = false;
    do {
        changed = false;
        // 0個または1個の要素しか持たないグループを抽出
        const toDel = state.groups.filter(g => {
            const notes = state.notes.filter(n => n.groupId === g.id);
            const subs = state.groups.filter(gr => gr.groupId === g.id);
            return (notes.length + subs.length) <= 1;
        });

        if (toDel.length > 0) {
            toDel.forEach(g => {
                const parentId = g.groupId;
                // 中身（もしあれば）の親を、削除されるグループの親に書き換える
                state.notes.forEach(n => { if (n.groupId === g.id) n.groupId = parentId; });
                state.groups.forEach(gr => { if (gr.groupId === g.id) gr.groupId = parentId; });
                // グループ自体を削除
                state.groups = state.groups.filter(gr => gr.id !== g.id);

                // 入れ子構造が解消されたことで、親も「1つしか持たない」状態になる可能性があるのでループを継続
                changed = true;
            });
        }
    } while (changed);

    if (state.groups.length >= 0) { // 常に行う
        renderCanvas();
    }
}

// ============================================================================
// UTILITIES
// ============================================================================
function getRandomColor() { return CONSTANTS.COLORS[Math.floor(Math.random() * CONSTANTS.COLORS.length)]; }
function escapeHtml(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
function isParentCollapsed(id, v = new Set()) { if (!id || v.has(id)) return false; v.add(id); const g = state.groups.find(x => x.id === id); return g ? (g.collapsed || isParentCollapsed(g.groupId, v)) : false; }
function openNoteModal() { DOM.noteModal.classList.add('active'); DOM.noteTitleInput.value = ''; DOM.noteInput.value = ''; DOM.noteTitleInput.focus(); }
function closeNoteModal() { DOM.noteModal.classList.remove('active'); DOM.noteTitleInput.value = ''; DOM.noteInput.value = ''; }
function openImportModal() { DOM.importModal.classList.add('active'); DOM.importInput.focus(); }
function closeImportModal() { DOM.importModal.classList.remove('active'); DOM.importInput.value = ''; }
function openViewModal(n) { DOM.viewTitle.textContent = n.title || 'ノート閲覧'; DOM.viewBody.textContent = n.content; DOM.viewModal.classList.add('active'); }
function closeViewModal() { DOM.viewModal.classList.remove('active'); }
function toggleView() { DOM.canvasView.classList.toggle('active'); DOM.outlinerView.classList.toggle('active'); }
function rotateColor(it) { const c = CONSTANTS.COLORS; it.color = c[(c.indexOf(it.color || 'slate') + 1) % c.length]; saveData(); renderCanvas(); }
function deleteItem(id, type) {
    if (state.pendingDelete && state.pendingDelete.id === id) {
        pushHistory();
        if (type === 'note') state.notes = state.notes.filter(n => n.id !== id);
        else if (type === 'group') {
            state.groups = state.groups.filter(g => g.id !== id);
            state.notes.forEach(n => { if (n.groupId === id) n.groupId = null; });
            state.groups.forEach(g => { if (g.groupId === id) g.groupId = null; });
        }
        state.pendingDelete = null; renderCanvas(); saveData();
    } else {
        state.pendingDelete = { id, timer: setTimeout(() => { state.pendingDelete = null; renderCanvas(); }, 3000) };
        renderCanvas();
    }
}

function attachGroupEventListeners(el, g) {
    el.onmousedown = e => {
        const edge = !g.collapsed && getResizeEdge(e, el);
        if (edge) startResize(e, g, edge); else startDrag(e, 'group');
    };
    el.onmousemove = e => {
        if (!g.collapsed && !state.dragType) {
            const edge = getResizeEdge(e, el);
            el.style.cursor = edge ? getResizeCursor(edge) : 'grab';
        }
    };
    el.querySelector('input').onclick = e => e.stopPropagation();
    el.querySelector('input').onchange = e => { pushHistory(); g.title = e.target.value; saveData(); };
    el.querySelector('.btn-collapse').onclick = e => { e.stopPropagation(); g.collapsed = !g.collapsed; renderCanvas(); saveData(); };
    el.querySelector('.btn-duplicate').onclick = e => { e.stopPropagation(); duplicateItem(g.id, 'group'); };
    el.querySelector('.btn-connect').onclick = e => { e.stopPropagation(); state.connectingSource = g.id; renderCanvas(); };
    el.querySelector('.btn-ghost').onclick = e => { e.stopPropagation(); g.isGhost = !g.isGhost; renderCanvas(); };
    el.querySelector('.btn-delete').onclick = e => { e.stopPropagation(); deleteItem(g.id, 'group'); };
    el.querySelector('.btn-color').onclick = e => { e.stopPropagation(); rotateColor(g); };
}
function attachNoteEventListeners(el, n) {
    el.onmousedown = e => {
        const edge = !n.collapsed && getResizeEdge(e, el);
        if (edge) startResize(e, n, edge); else startDrag(e, 'note');
    };
    el.onmousemove = e => {
        if (!n.collapsed && !state.dragType) {
            const edge = getResizeEdge(e, el);
            el.style.cursor = edge ? getResizeCursor(edge) : 'grab';
        }
    };
    el.querySelector('.title-input').onclick = e => e.stopPropagation();
    el.querySelector('.title-input').onchange = e => { pushHistory(); n.title = e.target.value; saveData(); };
    el.querySelector('.btn-collapse').onclick = e => { e.stopPropagation(); n.collapsed = !n.collapsed; renderCanvas(); saveData(); };
    el.querySelector('.btn-maximize').onclick = e => { e.stopPropagation(); openViewModal(n); };
    el.querySelector('.btn-duplicate').onclick = e => { e.stopPropagation(); duplicateItem(n.id, 'note'); };
    el.querySelector('.btn-connect').onclick = e => { e.stopPropagation(); state.connectingSource = n.id; renderCanvas(); };
    el.querySelector('.btn-ghost').onclick = e => { e.stopPropagation(); n.isGhost = !n.isGhost; renderCanvas(); };
    el.querySelector('.btn-delete').onclick = e => { e.stopPropagation(); deleteItem(n.id, 'note'); };
    el.querySelector('.btn-color').onclick = e => { e.stopPropagation(); rotateColor(n); };
}

function findEmptyPosition(sx, sy, w, h) {
    let x = sx, y = sy, r = 0, a = 0;
    while (isOverlapping(x, y, w, h) && r < 2000) { r += 50; a += 0.5; x = sx + r * Math.cos(a); y = sy + r * Math.sin(a); }
    return { x, y };
}
function isOverlapping(x, y, w, h) {
    return state.notes.some(n => !(x + w < n.x || n.x + 300 < x || y + h < n.y || n.y + 150 < y)) ||
        state.groups.some(g => !(x + w < g.x || g.x + (g.width || 400) < x || y + h < g.y || g.y + (g.height || 300) < y));
}

function getResizeEdge(e, el) {
    const r = el.getBoundingClientRect(); const x = e.clientX - r.left; const y = e.clientY - r.top;
    const nearBottom = y > r.height - 12; const nearRight = x > r.width - 12;
    if (nearBottom && nearRight) return 'se'; if (nearBottom) return 's'; if (nearRight) return 'e'; return null;
}
function getResizeCursor(edge) {
    const cursors = { 's': 'ns-resize', 'e': 'ew-resize', 'se': 'nwse-resize' };
    return cursors[edge] || 'grab';
}

function addGroup() {
    pushHistory();
    const p = findEmptyPosition(currentMouseCanvasPos.x, currentMouseCanvasPos.y, 400, 300);
    state.groups.push({ id: 'g' + Date.now(), title: '新規', x: p.x, y: p.y, width: 400, height: 300, groupId: null, collapsed: false, color: getRandomColor() });
    renderCanvas(); saveData();
}

function saveNote() {
    const t = DOM.noteTitleInput.value.trim();
    const c = DOM.noteInput.value.trim();
    if (!c && !t) return;
    pushHistory();
    const p = findEmptyPosition(currentMouseCanvasPos.x, currentMouseCanvasPos.y, 300, 150);
    const n = { id: Date.now(), title: t, content: c, x: p.x, y: p.y, width: CONSTANTS.NOTE_WIDTH, height: CONSTANTS.NOTE_HEIGHT, color: getRandomColor(), collapsed: false };
    state.notes.push(n);
    renderCanvas(); saveData(); closeNoteModal();
}


function renderRelations(svg, labelsLayer) {
    state.relations.forEach(r => {
        const s = state.notes.find(n => n.id === r.source) || state.groups.find(g => g.id === r.source);
        const t = state.notes.find(n => n.id === r.target) || state.groups.find(g => g.id === r.target);
        if (!s || !t) return;
        if (isParentCollapsed(s.groupId) || isParentCollapsed(t.groupId)) return;

        const b1 = getItemBounds(s);
        const b2 = getItemBounds(t);
        const p = getNearestBoundaryPoints(b1.x, b1.y, b1.w, b1.h, b2.x, b2.y, b2.w, b2.h);

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', p.x1); line.setAttribute('y1', p.y1);
        line.setAttribute('x2', p.x2); line.setAttribute('y2', p.y2);
        line.setAttribute('stroke', '#94a3b8'); line.setAttribute('stroke-width', '2');
        if (r.dash && r.dash !== 'none') line.setAttribute('stroke-dasharray', r.dash);
        svg.appendChild(line);

        if (labelsLayer) {
            const midX = (p.x1 + p.x2) / 2;
            const midY = (p.y1 + p.y2) / 2;
            const pill = document.createElement('div');
            pill.className = 'relation-label-container';
            pill.style.left = `${midX}px`;
            pill.style.top = `${midY}px`;
            pill.title = 'ダブルクリックで削除';

            const input = document.createElement('input');
            input.className = 'relation-label-input';
            input.value = r.label || '';
            input.placeholder = '名称なし';
            input.onchange = e => { pushHistory(); r.label = e.target.value; saveData(); };
            input.onmousedown = e => e.stopPropagation();

            // ダブルクリックで削除
            pill.ondblclick = e => {
                e.stopPropagation();
                pushHistory();
                state.relations = state.relations.filter(rel => rel.id !== r.id);
                saveData();
                renderCanvas();
            };

            pill.appendChild(input);
            labelsLayer.appendChild(pill);
        }
    }); // End state.relations.forEach

    if (state.connectingSource) {
        const s = state.notes.find(n => n.id === state.connectingSource) || state.groups.find(g => g.id === state.connectingSource);
        if (s) {
            const b = getItemBounds(s);
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', b.x + b.w / 2); line.setAttribute('y1', b.y + b.h / 2);
            line.setAttribute('x2', currentMouseCanvasPos.x); line.setAttribute('y2', currentMouseCanvasPos.y);
            line.setAttribute('stroke', '#3b82f6'); line.setAttribute('stroke-width', '2');
            svg.appendChild(line);
        }
    }
}

function getNearestBoundaryPoints(x1, y1, w1, h1, x2, y2, w2, h2) {
    const intersect = (ax, ay, aw, ah, tx, ty) => {
        const cx = ax + aw / 2;
        const cy = ay + ah / 2;
        const dx = tx - cx;
        const dy = ty - cy;
        if (dx === 0 && dy === 0) return { x: cx, y: cy };

        // 交点を計算。ターゲットの中心を結ぶ直線上
        const scaleX = (aw / 2) / Math.abs(dx);
        const scaleY = (ah / 2) / Math.abs(dy);
        const scale = Math.min(scaleX, scaleY);

        return { x: cx + dx * scale, y: cy + dy * scale };
    };

    // 中点同士を結ぶ線上の、それぞれの境界線上の点を求める
    const c1x = x1 + w1 / 2; const c1y = y1 + h1 / 2;
    const c2x = x2 + w2 / 2; const c2y = y2 + h2 / 2;

    const p1 = intersect(x1, y1, w1, h1, c2x, c2y);
    const p2 = intersect(x2, y2, w2, h2, c1x, c1y);
    return { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y };
}
function renderQuickActions() {
    if (state.selectedIds.length < 2) return;
    const items = state.selectedIds.map(id => state.notes.find(n => n.id === id) || state.groups.find(g => g.id === id)).filter(Boolean);
    if (items.length < 2) return;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    items.forEach(it => { minX = Math.min(minX, it.x); minY = Math.min(minY, it.y); maxX = Math.max(maxX, it.x + (it.width || 300)); maxY = Math.max(maxY, it.y + (it.height || 150)); });
    const container = document.createElement('div');
    container.className = 'quick-action-container';
    container.style.left = `${(minX + maxX) / 2}px`; container.style.top = `${(minY + maxY) / 2}px`;
    const btn = document.createElement('button');
    btn.className = 'quick-btn'; btn.innerHTML = `${state.selectedIds.length}個をグループ化`;
    btn.onclick = () => {
        pushHistory();
        const id = 'g' + Date.now();
        state.groups.push({ id, title: '新規', x: minX - 24, y: minY - 64, width: maxX - minX + 48, height: maxY - minY + 88, color: getRandomColor(), groupId: null });
        state.selectedIds.forEach(sid => { const n = state.notes.find(x => x.id === sid); if (n) n.groupId = id; const g = state.groups.find(x => x.id === sid); if (g) g.groupId = id; });
        state.selectedIds = []; updateGroupBounds(id); saveData(); renderCanvas();
    };
    container.appendChild(btn);

    if (state.selectedIds.length === 2) {
        const relBtn = document.createElement('button');
        relBtn.className = 'quick-btn'; relBtn.style.background = '#64748b'; relBtn.innerHTML = `関係付ける`;
        relBtn.onclick = () => {
            pushHistory();
            state.relations.push({
                source: state.selectedIds[0],
                target: state.selectedIds[1],
                id: Date.now(),
                dash: CONSTANTS.DASH_PATTERNS[Math.floor(Math.random() * CONSTANTS.DASH_PATTERNS.length)]
            });
            state.selectedIds = []; saveData(); renderCanvas();
        };
        container.appendChild(relBtn);
    }

    DOM.canvas.appendChild(container);
}
function renderOutline() {
    if (!DOM.outlineList) return;
    DOM.outlineList.innerHTML = '';
    const root = [...state.groups.filter(g => !g.groupId), ...state.notes.filter(n => !n.groupId)].filter(it => !it.isGhost);
    root.forEach(it => DOM.outlineList.appendChild(createOutlineItem(it)));
}

function createOutlineItem(it) {
    const el = document.createElement('div');
    el.className = 'outline-item';
    const isG = typeof it.id === 'string';
    el.innerHTML = `<div class="outline-header ${isG ? 'is-group' : 'is-note'}"><span>${escapeHtml(it.title || (isG ? '無題のグループ' : '無題のノート'))}</span></div>`;

    if (isG) {
        const children = [...state.groups.filter(g => g.groupId === it.id), ...state.notes.filter(n => n.groupId === it.id)].filter(c => !c.isGhost);
        if (children.length > 0) {
            const container = document.createElement('div');
            container.className = 'outline-children';
            children.forEach(c => container.appendChild(createOutlineItem(c)));
            el.appendChild(container);
        }
    } else {
        const summary = document.createElement('div');
        summary.className = 'outline-content-summary';
        summary.textContent = it.content.length > 50 ? it.content.substring(0, 50) + '...' : it.content;
        el.appendChild(summary);
    }
    return el;
}

// ============================================================================
// HISTORY & REPLICATION
// ============================================================================
function pushHistory() {
    const snapshot = JSON.stringify({
        notes: state.notes,
        groups: state.groups,
        relations: state.relations,
        outlineOrder: state.outlineOrder
    });
    if (state.history.past.length > 0 && state.history.past[state.history.past.length - 1] === snapshot) return;
    state.history.past.push(snapshot);
    if (state.history.past.length > 50) state.history.past.shift();
    state.history.future = [];
    updateUndoRedoButtons();
}

function undo() {
    if (state.history.past.length === 0) return;
    const current = JSON.stringify({
        notes: state.notes,
        groups: state.groups,
        relations: state.relations,
        outlineOrder: state.outlineOrder
    });
    state.history.future.push(current);
    const prev = JSON.parse(state.history.past.pop());
    state.notes = prev.notes;
    state.groups = prev.groups;
    state.relations = prev.relations;
    state.outlineOrder = prev.outlineOrder;
    renderCanvas(); saveData();
}

function redo() {
    if (state.history.future.length === 0) return;
    const current = JSON.stringify({
        notes: state.notes,
        groups: state.groups,
        relations: state.relations,
        outlineOrder: state.outlineOrder
    });
    state.history.past.push(current);
    const next = JSON.parse(state.history.future.pop());
    state.notes = next.notes;
    state.groups = next.groups;
    state.relations = next.relations;
    state.outlineOrder = next.outlineOrder;
    renderCanvas(); saveData();
}

function updateUndoRedoButtons() {
    if (DOM.undoBtn) DOM.undoBtn.disabled = state.history.past.length === 0;
    if (DOM.redoBtn) DOM.redoBtn.disabled = state.history.future.length === 0;
}

function duplicateItem(id, type) {
    pushHistory();
    const offset = 40;
    if (type === 'note') {
        const n = state.notes.find(x => x.id === id);
        if (n) state.notes.push({ ...n, id: Date.now(), x: n.x + offset, y: n.y + offset });
    } else {
        const g = state.groups.find(x => x.id === id);
        if (g) {
            const nextGid = 'g' + Date.now();
            state.groups.push({ ...g, id: nextGid, x: g.x + offset, y: g.y + offset });
            duplicateChildren(id, nextGid, offset, offset);
        }
    }
    renderCanvas(); saveData();
}

function duplicateChildren(oldId, newId, dx, dy) {
    state.notes.filter(n => n.groupId === oldId).forEach(n => {
        state.notes.push({ ...n, id: Date.now() + Math.random(), groupId: newId, x: n.x + dx, y: n.y + dy });
    });
    state.groups.filter(g => g.groupId === oldId).forEach(g => {
        const nextGid = 'g' + (Date.now() + Math.random());
        state.groups.push({ ...g, id: nextGid, groupId: newId, x: g.x + dx, y: g.y + dy });
        duplicateChildren(g.id, nextGid, dx, dy);
    });
}

// ============================================================================
// RESIZING LOGIC
// ============================================================================
function startResize(e, item, edge) {
    e.stopPropagation();
    state.dragItem = item;
    state.dragType = 'resize';
    state.resizeEdge = edge;
    state.originalBounds = {
        width: item.width || (typeof item.id === 'number' ? CONSTANTS.NOTE_WIDTH : CONSTANTS.DEFAULT_GROUP_WIDTH),
        height: item.height || (typeof item.id === 'number' ? CONSTANTS.NOTE_HEIGHT : CONSTANTS.DEFAULT_GROUP_HEIGHT),
        x: item.x,
        y: item.y
    };
    pushHistory();
}

function handleResize(e) {
    if (!state.dragItem || !state.resizeEdge || !state.originalBounds) return;
    const item = state.dragItem;
    const rect = DOM.canvasContainer.getBoundingClientRect();
    const mx = (e.clientX - rect.left) / state.zoom - state.offset.x;
    const my = (e.clientY - rect.top) / state.zoom - state.offset.y;

    if (state.resizeEdge.includes('s')) {
        item.height = Math.max(80, my - item.y);
    }
    if (state.resizeEdge.includes('e')) {
        item.width = Math.max(120, mx - item.x);
    }

    if (item.groupId) updateGroupBounds(item.groupId);
}

init();
